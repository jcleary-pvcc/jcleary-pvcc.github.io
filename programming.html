<!DOCTYPE html>
<!-- NAME: Joshua Cleary
	Credits: 
	Color palette: https://lospec.com/palette-list/patina
     PROGRAM PURPOSE:   -->
<html lang="en">

<head>
<title> Programming </title>
<style>
    
  body {background-color:#631e17;
      font-family: calibri;
    }
  h1 {color: #5fb391; font-size: 1.8em; margin-left: 1em; text-align: center;}
  th {color: #d3eed3;}
  tr {color: #93d4b5;}
  table {width: 800px; font-size: 1.3em; font-weight: bold; background-color: #78482a; margin:auto; }
  
  </style>
	</head>
	
<body>
    <h1>Chapter 5: Programming Algorithms & Software Testing</h1>
<table>
<td>
	<h3>Phases of computer program development:</h2>
<ol>
	<li> Phase 1: Understand the problem </li>
	<li> Phase 2: Design an algorithm to solve the problem </li>
	<li> Phase 3: Write the program code in appropriate language based on the algorithm </li>
	<li> Phase 4: Enter the program and save </li>
	<li> Phase 5: Execute the program </li>
	<li> Phase 6: Test the program, find errors and debug, then retest </li>
	<li> Phase 7: Document and evaluate the program </li>
</ol>

	<h3>Programming Structures:</h3>
<ul>
	<li>Sequential structure: Top-down execution</li>
	<li>Decision structures: if/then/else</li>
	<li>Iterative: (Looping) </li>
	<ul> 
		<li> while loop: continue looping as long as something is true </li>
		<li> repeat/until loop: continue looping until something is true </li>
		<li> for loop: loop a given number of times </li>
	</ul>
	<li> Recursive Structures: </li>
	<ul>
		<li> Repeat a set of instructions as a subtask of itself </li>
		<li> Repetition continues until: </li>
			<ul> <li> degenerative case, which is a termination condition, is met </li>
			<li> (degenerative case is also called a "base case") </li> </ul>
	</ul>
</ul>
	<h3> Two classic programming/database problems </h3>
<ul>
	<li>Sorting: Descending order/Ascending order	</li>
	<ul> <li> Sorting numbers </li>
		<li> Sorting strings (in accordance with ASCII values) </li>
		</ul>
	<li> Searching: find specific data that meet a certain criteria </li>
	<ul> <li> In database: </li>
		<ul> <li> Filters: temporary search </li>
			<li> Queries: search criteria are saved so they don't have to be recreated </li> </ul>
	</ul>
	<li> Two popular search techniques: </li>
	<ul> <li> Sequential search: search from top to bottom or bottom to top, one item at a time </li> 
		<li> Binary search: </li>
		<ul> <li> only works if data is SORTED first </li>
			<li> start in the middle, then go to half of that, etc. </li> </ul>
	</ul>
</ul>
	<h3> Two classic program goals: </h3>
<ul>
	<li> Efficiency: Program takes minimal time and/or resources </li>
	<li> Correctness: Program runs in expected ways and works for all expected conditions </li>
</ul>

	<h3> Software testing and verification </h3>
<ul>
	<li> Kinds of tests: </li>
	<ul> <li> Acceptance Testing: Tests to see if the system works as intended</li>
		<li> Integration Testing: Ensuring all components work together</li>
		<li> Unit Testing: Ensuring a single component works as intended</li>
		<li> Functional Testing: Checks functions based on simulated scenarios where the would be used </li>
		<li> Performance Testing: Tests how a function works under various workloads/performances</li>
		<li> Regression Testing: Tests if a new feature alters functionality in a negative way</li>
		<li> Stress Testing: Tests the maximum "strain" a program can take: mass user count is a common method.</li>
		<li> Usability Testing: Tests how well the end user can use the program</li>
	</ul>
	<li> Software testing is done to detect: </li>
	<ul> <li> Arcitectural flaws </li>
		<li> Poor design decisions</li>
		<li> Invalid or incorrect functionality</li>
		<li> Security vulnerabilities</li>
		<li> Scalability issues</li>
	</ul>
	<li> Testing Best practices: </li>
	<ul> <li>Continuous testing: Testing every version made of a program, as they are made </li>
		<li>Configuration management: Maintaining "configurations" of computers for testing </li>
		<li>Service virtualization: Allows emulating/simulating various programs and services. Common are OSes/entire computers. Useful to test on differing systems cheaply.</li>
		<li>Defect or "bug tracking": Recording discovered issues in software/products, allows efficient management of discovered bugs. </li>
		<li>Metrics and reporting: recorded data on a chosen aspect of a chosen subject, such as users that pay for premium versions. </li>
	</ul>
</ul>
<h2> <a href= https://www.ibm.com/topics/software-testing> From IBM: What is software testing? </a> </h2>

</td>
</table>
</body

</html>
